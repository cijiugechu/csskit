use crate::ignore_properties::get_ignore_properties;
use crate::manual_parse_properties::get_manual_parse_properties;
use crate::shorthands::get_shorthand_properties;
use crate::spec_parser::PropertyDefinition;
use crate::todo_properties::get_todo_properties;
use crate::value_extensions::get_value_extensions;
use crate::web_features_data::{BaselineStatus, FeatureData, StringOrArray, WebFeaturesData};
use css_value_definition_parser::Def;
use heck::ToPascalCase;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use std::collections::{HashMap, HashSet};
use syn::{File, parse2};

/// Generate Rust code for a CSS spec module
pub fn generate_spec_module(
	spec_name: &str,
	version: usize,
	properties: &[PropertyDefinition],
	spec_title: Option<&str>,
	property_descriptions: &HashMap<String, String>,
	csswg_sha: Option<&str>,
) -> String {
	let url = format!("https://drafts.csswg.org/css-{}-{}/", spec_name, version);

	let module_doc =
		if let Some(title) = spec_title { format!("//! {}\n//! {}\n", title, url) } else { format!("//! {}\n", url) };

	let autogen_notice = if let Some(sha) = csswg_sha {
		format!(
			"// AUTO-GENERATED from w3c/csswg-drafts\n// Commit: https://github.com/w3c/csswg-drafts/commit/{}\n// Do not edit this file directly.\n",
			sha
		)
	} else {
		"// AUTO-GENERATED - Do not edit this file directly.\n".to_string()
	};

	let ignore_properties = get_ignore_properties();
	let should_ignore: HashSet<String> = ignore_properties.get(spec_name).cloned().unwrap_or_default();

	let mut filtered_properties: Vec<_> =
		properties.iter().filter(|prop| !should_ignore.contains(&prop.name)).collect();
	filtered_properties.sort_by_key(|prop| &prop.name);

	let todo_properties = get_todo_properties();
	let should_comment_out: HashSet<String> = todo_properties.get(spec_name).cloned().unwrap_or_default();

	let value_extensions = get_value_extensions();
	let spec_extensions = value_extensions.get(spec_name);

	let manual_parse_properties = get_manual_parse_properties();
	let should_skip_parse: HashSet<String> = manual_parse_properties.get(spec_name).cloned().unwrap_or_default();

	let property_types = filtered_properties.iter().map(|prop| {
		let description = property_descriptions.get(&prop.name);
		let extension = spec_extensions.and_then(|ext| ext.get(&prop.name).map(|s| s.as_str()));
		let skip_parse = should_skip_parse.contains(&prop.name);
		generate_property_type(spec_name, version, prop, description, extension, skip_parse)
	});

	let tokens = quote! {
		mod impls;

		use super::prelude::*;
		use impls::*;

		#(#property_types)*
	};

	let file: File = syn::parse2(tokens).expect("generated code should parse");
	let mut code = prettyplease::unparse(&file);

	code = format!("{}{}{}\n{}", autogen_notice, "#![allow(warnings)]\n", module_doc, code);

	code = fix_formatting(&code, spec_name, version, &filtered_properties);

	code = add_blank_lines_between_properties(&code);

	comment_out_properties(&code, &filtered_properties, &should_comment_out)
}

fn fix_formatting(code: &str, spec_name: &str, version: usize, properties: &[&PropertyDefinition]) -> String {
	let mut result = String::new();

	for line in code.lines() {
		let mut fixed_line = line.to_string();

		if fixed_line.starts_with("///") && !fixed_line.starts_with("/// ") {
			fixed_line = fixed_line.replacen("///", "/// ", 1);
		}

		if fixed_line.contains(&format!("css-{}-{}", spec_name, version)) {
			for prop in properties {
				let property_id = if prop.name == "--*" { "defining-variables" } else { &prop.name };
				let wrong_url = format!("css-{}-{}#{}", spec_name, version, property_id);
				let correct_url = format!("css-{}-{}/#{}", spec_name, version, property_id);
				fixed_line = fixed_line.replace(&wrong_url, &correct_url);
			}
		}

		result.push_str(&fixed_line);
		result.push('\n');
	}

	result
}

fn add_blank_lines_between_properties(code: &str) -> String {
	let lines: Vec<&str> = code.lines().collect();
	let mut result = Vec::new();
	let mut prev_was_property_end = false;

	for (i, line) in lines.iter().enumerate() {
		let is_property_start = line.starts_with("/// Represents the style value for");

		if is_property_start && prev_was_property_end && i > 0 {
			result.push(String::new());
		}

		result.push(line.to_string());

		let is_enum_end = line.starts_with("pub enum ") && line.contains("StyleValue") && line.ends_with(" {}");
		let is_struct_end = line.starts_with("pub struct ") && line.contains("StyleValue") && line.ends_with(";");
		let is_property_end = is_enum_end || is_struct_end;

		prev_was_property_end = is_property_end;
	}

	result.join("\n")
}

fn comment_out_properties(
	code: &str,
	properties: &[&PropertyDefinition],
	should_comment_out: &HashSet<String>,
) -> String {
	let lines: Vec<&str> = code.lines().collect();
	let mut result = Vec::new();
	let mut in_commented_property = false;

	for line in lines.iter() {
		if line.starts_with("/// Represents the style value for") {
			in_commented_property = properties
				.iter()
				.any(|prop| should_comment_out.contains(&prop.name) && line.contains(&format!("`{}`", prop.name)));
		}

		if in_commented_property {
			if line.trim().is_empty() {
				result.push(String::new());
			} else {
				result.push(format!("// {}", line));
			}

			if line.starts_with("pub enum ") || line.starts_with("pub struct ") {
				in_commented_property = false;
			}
		} else {
			result.push(line.to_string());
		}
	}

	result.join("\n")
}

/// Convert the "inherited" field from spec into a DeclarationMetadata attribute
fn convert_inherited(inherited: &str) -> Option<TokenStream> {
	let normalized = inherited.replace('\n', " ").to_lowercase();
	match normalized.as_str() {
		"no" => None,
		"yes" => Some(quote! { inherits }),
		// "n/a" means not applicable - treat as Unknown
		"n/a" => Some(quote! { inherits = Unknown }),
		// "no (but see prose)" means complex inheritance rules - treat as no
		s if s.starts_with("no") && s.contains("prose") => None,
		// Catch-all for complex cases like "see individual properties"
		_ => {
			eprintln!("Warning: Unknown inherits value: {}", inherited);
			Some(quote! { inherits = Unknown })
		}
	}
}

/// Convert the "percentages" field from spec into a DeclarationMetadata attribute
fn convert_percentages(percentages: &str) -> Option<TokenStream> {
	let normalized = percentages.replace('\n', " ").to_lowercase();
	match normalized.as_str() {
		"n/a" => None,
		"computed relative to 1em" | "relative to computed font-size, i.e. 1em" => {
			Some(quote! { percentages = FontSize })
		}
		"not resolved" => Some(quote! { percentages = None }),
		"converted to <number>" => Some(quote! { percentages = Number }),
		"refer to parent element's font size" => Some(quote! { percentages = ParentFontSize }),
		"refer to corresponding dimension of the border box." | "relative to border-box" => {
			Some(quote! { percentages = BorderBox })
		}
		"refer to size of containing block; see prose"
		| "refer to logical width of containing block"
		| "refer to the inline size of the containing block"
		| "relative to width/height of containing block" => Some(quote! { percentages = ContainingBlock }),

		// Scroll-related
		s if s.contains("scroll") && s.contains("scrollport") => Some(quote! { percentages = Scrollport }),

		// Content area
		s if s.contains("content area") => Some(quote! { percentages = ContentArea }),

		// Border edge
		s if s.contains("border-edge") || s.contains("border edge") => Some(quote! { percentages = BorderEdge }),

		// Background positioning area
		s if s.contains("background positioning area") => Some(quote! { percentages = BackgroundPositioningArea }),

		// Reference box
		s if s.contains("reference box") => Some(quote! { percentages = ReferenceBox }),

		// Element itself
		s if s.contains("element itself") => Some(quote! { percentages = SelfSize }),

		// Line box
		s if s.contains("line box") || s.contains("line-height") => Some(quote! { percentages = LineBox }),

		// Flex container
		s if s.contains("flex container") => Some(quote! { percentages = FlexContainer }),

		// Border image
		s if s.contains("border image") => Some(quote! { percentages = BorderImageArea }),

		// Normalized range
		s if s.contains("map to the range") || s.contains("[0,1]") => Some(quote! { percentages = NormalizedRange }),

		// Logical properties that reference physical ones
		s if s.contains("as for the corresponding physical property") => Some(quote! { percentages = Unknown }),

		// Catch-all for "see individual properties", "see prose", etc.
		_ => {
			eprintln!("Warning: Unknown percentages value: {}", percentages);
			Some(quote! { percentages = Unknown })
		}
	}
}

/// Convert the "applies to" field from spec into a DeclarationMetadata attribute
fn convert_applies_to(applies_to: &str) -> Option<TokenStream> {
	let result = match applies_to.replace('\n', " ").to_lowercase().as_str() {
		"n/a" => return None,
		"absolutely positioned boxes" => quote! { applies_to = AbsPos },
		"all elements and text" => quote! { applies_to = Elements | Text },
		"all elements and pseudo-elements" => quote! { applies_to = Elements | PseudoElements },
		"all elements."
		| "all elements"
		| "all enabled elements"
		| "all elements (but see prose)"
		| "all elements, but not pseudo-elements"
		| "all elements, but see prose" => {
			quote! { applies_to = Elements }
		}
		"text" => quote! { applies_to = Text },
		"block containers" | "block-level boxes" | "block-level elements" | "block container elements" => {
			quote! { applies_to = Block }
		}
		"flex containers" => quote! { applies_to = Flex },
		"grid containers" => quote! { applies_to = Grid },
		"floats" => quote! { applies_to = Float },
		_ => quote! { applies_to = Unknown },
	};
	Some(result)
}

/// Convert the "animation type" field from spec into a DeclarationMetadata attribute
fn convert_animation_type(animation_type: &str) -> Option<TokenStream> {
	let normalized = animation_type.replace('\n', " ").to_lowercase();
	match normalized.as_str() {
		"n/a" | "none" | "not animatable" => None,
		"discrete" => Some(quote! { animation_type = Discrete }),

		// By computed value (various phrasings)
		"by computed value type" | "by computed value" => Some(quote! { animation_type = ByComputedValue }),

		// Specific animation types
		s if s.contains("transform list") => Some(quote! { animation_type = TransformList }),
		s if s.contains("shadow list") => Some(quote! { animation_type = ShadowList }),
		"as length" => Some(quote! { animation_type = Length }),
		"number" => Some(quote! { animation_type = Number }),

		// Repeatable list
		s if s.contains("repeatable list") => Some(quote! { animation_type = RepeatableList }),

		// Conditional discrete (treat as discrete)
		s if s.contains("discrete") => Some(quote! { animation_type = Discrete }),

		// By computed value with special cases
		s if s.contains("by computed value") => Some(quote! { animation_type = ByComputedValue }),

		// Catch-all for "see individual properties", complex cases, etc.
		_ => {
			eprintln!("Warning: Unknown animation_type value: {}", animation_type);
			Some(quote! { animation_type = Unknown })
		}
	}
}

/// Convert the "computed value" field from spec into a DeclarationMetadata attribute
fn convert_computed_value(computed_value: &str) -> Option<TokenStream> {
	let normalized = computed_value.replace('\n', " ").to_lowercase();
	let result = match normalized.as_str() {
		s if s.contains("as specified") && s.contains("absolute length") => {
			quote! { computed_value_type = SpecifiedWithAbsoluteLengths }
		}
		s if s.contains("as specified") && s.contains("absolute") && s.contains("url") => {
			quote! { computed_value_type = SpecifiedWithAbsoluteUrls }
		}
		s if s.starts_with("as specified") || s == "specified value" => {
			quote! { computed_value_type = AsSpecified }
		}
		s if s.contains("absolute length") && s.contains("percentage") => {
			quote! { computed_value_type = AbsoluteLengthOrPercentage }
		}
		s if s.contains("absolute length") && s.contains("none") => {
			quote! { computed_value_type = AbsoluteLengthOrNone }
		}
		s if s.contains("absolute length") && (s.contains("keyword") || s.contains("specified")) => {
			quote! { computed_value_type = SpecifiedKeywordPlusAbsoluteLength }
		}
		s if s.contains("two absolute length") => {
			quote! { computed_value_type = TwoAbsoluteLengths }
		}
		s if s.contains("list") && s.contains("absolute length") => {
			quote! { computed_value_type = ListOfAbsoluteLengths }
		}
		s if s.contains("absolute length") => {
			quote! { computed_value_type = AbsoluteLength }
		}
		_ => {
			quote! { computed_value_type = Unknown }
		}
	};
	Some(result)
}

/// Convert a spec name (e.g., "align", "anchor-position") to a PropertyGroup variant (e.g., "Align", "AnchorPosition")
fn spec_name_to_property_group(spec_name: &str) -> syn::Ident {
	// Convert kebab-case to PascalCase
	let pascal = spec_name
		.split('-')
		.map(|part| {
			let mut chars = part.chars();
			match chars.next() {
				None => String::new(),
				Some(first) => first.to_uppercase().chain(chars).collect(),
			}
		})
		.collect::<String>();

	syn::Ident::new(&pascal, proc_macro2::Span::call_site())
}

/// Determine which side(s) of the box a property applies to based on its name
fn determine_box_side(property_name: &str) -> Option<TokenStream> {
	// Some property names effect all sides of a box:
	if property_name == "margin" {
		return Some(quote! { box_side = Top | Bottom | Left | Right });
	}
	if property_name == "padding" {
		return Some(quote! { box_side = Top | Bottom | Left | Right });
	}
	if property_name == "border"
		|| property_name == "border-width"
		|| property_name == "border-style"
		|| property_name == "border-color"
	{
		return Some(quote! { box_side = Top | Bottom | Left | Right });
	}

	// Handle compound properties that reference corners (e.g., border-top-left-radius)
	// These should be marked with multiple sides
	if property_name.contains("-top-left") {
		return Some(quote! { box_side = Top | Left });
	}
	if property_name.contains("-top-right") {
		return Some(quote! { box_side = Top | Right });
	}
	if property_name.contains("-bottom-left") {
		return Some(quote! { box_side = Bottom | Left });
	}
	if property_name.contains("-bottom-right") {
		return Some(quote! { box_side = Bottom | Right });
	}

	// Logical corners
	if property_name.contains("-start-start") || property_name.contains("start-start") {
		return Some(quote! { box_side = BlockStart | InlineStart });
	}
	if property_name.contains("-start-end") || property_name.contains("start-end") {
		return Some(quote! { box_side = BlockStart | InlineEnd });
	}
	if property_name.contains("-end-start") || property_name.contains("end-start") {
		return Some(quote! { box_side = BlockEnd | InlineStart });
	}
	if property_name.contains("-end-end") || property_name.contains("end-end") {
		return Some(quote! { box_side = BlockEnd | InlineEnd });
	}

	// Physical sides
	if property_name.ends_with("-top") || property_name == "top" {
		return Some(quote! { box_side = Top });
	}
	if property_name.ends_with("-bottom") || property_name == "bottom" {
		return Some(quote! { box_side = Bottom });
	}
	if property_name.ends_with("-left") || property_name == "left" {
		return Some(quote! { box_side = Left });
	}
	if property_name.ends_with("-right") || property_name == "right" {
		return Some(quote! { box_side = Right });
	}

	// Logical sides - handle both with and without hyphens
	if property_name.ends_with("-block-start") || property_name == "block-start" {
		return Some(quote! { box_side = BlockStart });
	}
	if property_name.ends_with("-block-end") || property_name == "block-end" {
		return Some(quote! { box_side = BlockEnd });
	}
	if property_name.ends_with("-inline-start") || property_name == "inline-start" {
		return Some(quote! { box_side = InlineStart });
	}
	if property_name.ends_with("-inline-end") || property_name == "inline-end" {
		return Some(quote! { box_side = InlineEnd });
	}

	// Block axis (both block-start and block-end)
	// Match properties like "margin-block", "padding-block", "border-block"
	if property_name.contains("-block") && !property_name.contains("-start") && !property_name.contains("-end") {
		return Some(quote! { box_side = BlockStart | BlockEnd });
	}

	// Inline axis (both inline-start and inline-end)
	if property_name.contains("-inline") && !property_name.contains("-start") && !property_name.contains("-end") {
		return Some(quote! { box_side = InlineStart | InlineEnd });
	}

	None
}

/// Find the root shorthand for a property by recursively traversing the shorthand hierarchy.
/// For example, for `border-left-color`:
/// - It's a longhand of `border-color` and `border-left`
/// - `border-color` is a longhand of `border`
/// - `border-left` is a longhand of `border`
/// - So the root shorthand is `border`
fn find_root_shorthand(property_name: &str, shorthands: &HashMap<String, HashSet<String>>) -> Option<String> {
	let mut shorthands: Vec<String> = shorthands
		.iter()
		.filter(|(_, longhands)| longhands.contains(property_name))
		.map(|(shorthand, _)| {
			// Recursively find if this shorthand is itself a longhand of another shorthand
			find_root_shorthand(shorthand, shorthands).unwrap_or_else(|| shorthand.clone())
		})
		.collect();

	shorthands.sort();
	shorthands.dedup();

	shorthands.into_iter().min_by_key(|s| (s.len(), s.clone()))
}

/// Determine which portion(s) of the box model a property affects based on its name
fn determine_box_portion(property_name: &str) -> Option<TokenStream> {
	// Check for margin properties
	if property_name.starts_with("margin") || property_name == "margin" {
		return Some(quote! { box_portion = Margin });
	}

	// Check for padding properties
	if property_name.starts_with("padding") || property_name == "padding" {
		return Some(quote! { box_portion = Padding });
	}

	// Check for border properties
	// Note: border-radius doesn't really fit cleanly into border portion since it's more of a shape property
	// but we'll include it since it modifies the border area visually
	if property_name.starts_with("border") || property_name == "border" {
		return Some(quote! { box_portion = Border });
	}

	// Check for size properties (width/height and logical equivalents)
	// These affect the content box dimensions
	if matches!(
		property_name,
		"width"
			| "height"
			| "min-width"
			| "min-height"
			| "max-width"
			| "max-height"
			| "block-size"
			| "inline-size"
			| "min-block-size"
			| "min-inline-size"
			| "max-block-size"
			| "max-inline-size"
	) {
		return Some(quote! { box_portion = Size });
	}

	// Check for inset properties - these affect positioning but could be considered
	// as applying to multiple portions (they shift the entire box)
	if matches!(property_name, "inset" | "top" | "right" | "bottom" | "left" | "position")
		|| property_name.starts_with("inset-")
		|| property_name.starts_with("position-")
	{
		return Some(quote! { box_portion = Position });
	}

	None
}

fn generate_property_type(
	spec_name: &str,
	version: usize,
	prop: &PropertyDefinition,
	description: Option<&String>,
	value_extension: Option<&str>,
	skip_parse: bool,
) -> TokenStream {
	let shorthands = get_shorthand_properties();

	let type_name_base = if prop.name == "--*" { "Custom".to_string() } else { prop.name.to_pascal_case() };

	let property_id = if prop.name == "--*" { "defining-variables" } else { &prop.name };

	let type_name = syn::Ident::new(&format!("{}StyleValue", type_name_base), proc_macro2::Span::call_site());

	let extended_value =
		if let Some(extension) = value_extension { format!("{}{}", prop.value, extension) } else { prop.value.clone() };

	let grammar_cleaned = extended_value.replace("'", "\"").replace("âˆž", "");
	let (is_enum, needs_lifetime) = match grammar_cleaned.parse::<TokenStream>() {
		Ok(tokens) => match parse2::<Def>(tokens) {
			Ok(def) => {
				let optimized_def = def.optimize();
				let data_type = optimized_def.suggested_data_type();
				let is_enum = data_type.is_enum();
				let needs_lifetime = optimized_def.maybe_unsized();
				(is_enum, needs_lifetime)
			}
			Err(e) => {
				eprintln!("Warning: Failed to parse Def for {}: {} - Error: {}", prop.name, prop.value, e);
				(false, false)
			}
		},
		Err(e) => {
			eprintln!("Warning: Failed to tokenize syntax for {}: {} - Error: {}", prop.name, prop.value, e);
			(false, false)
		}
	};

	let doc_link_url = format!("https://drafts.csswg.org/css-{}-{}/#{}", spec_name, version, property_id);
	let doc_intro = format!(
		" Represents the style value for `{}` as defined in [css-{}-{}]({}).",
		prop.name, spec_name, version, doc_link_url
	);

	let doc_grammar_header = " The grammar is defined as:";
	let grammar = &extended_value;

	let doc_link = format!("https://drafts.csswg.org/css-{}-{}/#{}", spec_name, version, property_id);

	let syntax_value = format!(" {} ", extended_value.replace('\n', " "));

	// Build declaration_metadata attributes
	let initial = &prop.initial;
	let inherits_attr = convert_inherited(&prop.inherited);
	let applies_to_attr = convert_applies_to(&prop.applies_to);
	let percentages_attr = convert_percentages(&prop.percentages);
	let shorthand_group_attr = find_root_shorthand(&prop.name, &shorthands).map(|shorthand| {
		let ident = format_ident!("{}", shorthand.to_pascal_case());
		quote! { shorthand_group = #ident }
	});
	let longhands_attr = shorthands.get(&prop.name).and_then(|strings| {
		if strings.is_empty() {
			return None;
		};
		let mut idents = strings.iter().map(|string| format_ident!("{}", string.to_pascal_case())).collect::<Vec<_>>();
		idents.sort();
		Some(quote! { longhands = #(#idents)|* })
	});
	let animation_type_attr = prop.animation_type.as_ref().and_then(|a| convert_animation_type(a));
	let computed_value_attr = prop.computed_value.as_ref().and_then(|cv| convert_computed_value(cv));
	let canonical_order_attr = prop.canonical_order.as_ref().map(|order| {
		quote! { canonical_order = #order }
	});
	let logical_property_group_attr = prop.logical_property_group.as_ref().and_then(|g| {
		if g.is_empty() {
			None
		} else {
			let group = format_ident!("{}", g.to_pascal_case());
			Some(quote! { logical_property_group = #group })
		}
	});
	let property_group = spec_name_to_property_group(spec_name);
	let property_group_attr = Some(quote! { property_group = #property_group });
	let box_portion_attr = determine_box_portion(&prop.name);
	let box_side_attr = determine_box_side(&prop.name);

	let metadata_attrs = [
		Some(quote! { initial = #initial }),
		inherits_attr,
		applies_to_attr,
		animation_type_attr,
		percentages_attr,
		shorthand_group_attr,
		longhands_attr,
		property_group_attr,
		computed_value_attr,
		canonical_order_attr,
		logical_property_group_attr,
		box_side_attr,
		box_portion_attr,
	]
	.into_iter()
	.flatten();

	let css_feature = format!("css.properties.{}", prop.name);

	let (keyword, suffix) = if is_enum { (quote! { enum }, quote! { {} }) } else { (quote! { struct }, quote! { ; }) };

	let lifetime = if needs_lifetime {
		quote! { <'a> }
	} else {
		quote! {}
	};

	let doc_tokens = if let Some(desc) = description {
		let doc_desc = format!(" {}", desc);
		quote! {
			#[doc = #doc_intro]
			#[doc = ""]
			#[doc = #doc_desc]
			#[doc = ""]
			#[doc = #doc_grammar_header]
			#[doc = ""]
			#[doc = "```text,ignore"]
			#[doc = #grammar]
			#[doc = "```"]
			#[doc = ""]
			#[doc = #doc_link]
		}
	} else {
		quote! {
			#[doc = #doc_intro]
			#[doc = ""]
			#[doc = #doc_grammar_header]
			#[doc = ""]
			#[doc = "```text,ignore"]
			#[doc = #grammar]
			#[doc = "```"]
			#[doc = ""]
			#[doc = #doc_link]
		}
	};

	// Conditionally include Parse in derives based on skip_parse flag
	let derives = [
		if skip_parse {
			quote! {}
		} else {
			quote! { Parse }
		},
		quote! { Peek },
		quote! { ToSpan },
		quote! { ToCursors },
		quote! { DeclarationMetadata },
		quote! { SemanticEq },
		quote! { Debug },
		quote! { Clone },
		quote! { PartialEq },
		quote! { Eq },
		quote! { PartialOrd },
		quote! { Ord },
		quote! { Hash },
	]
	.into_iter()
	.filter_map(|x| if x.is_empty() { None } else { Some(x) });

	quote! {
		#doc_tokens
		#[syntax(#syntax_value)]
		#[derive(#(#derives,)*)]
		#[declaration_metadata(#(#metadata_attrs,)*)]
		#[cfg_attr(feature = "serde", derive(serde::Serialize), serde())]
		#[cfg_attr(feature = "css_feature_data", derive(ToCSSFeature), css_feature(#css_feature))]
		#[cfg_attr(feature = "visitable", derive(Visitable), visit)]
		pub #keyword #type_name #lifetime #suffix
	}
}

/// Generate CSS feature data as a Rust source file
pub fn generate_feature_data(web_features: &WebFeaturesData, popularity_map: &HashMap<String, f64>) -> String {
	let mut all_groups: HashMap<String, HashSet<String>> = HashMap::new();
	let mut all_specs: HashMap<String, HashSet<String>> = HashMap::new();
	let mut feature_entries: Vec<(String, TokenStream)> = Vec::new();

	// Collect all features
	for (feature_id, feature) in &web_features.features {
		if let Some(status) = &feature.status
			&& let Some(by_compat_key) = &status.by_compat_key
		{
			for (id, compat_status) in by_compat_key {
				if id.starts_with("css.") {
					let entry = generate_feature_entry_tokens(
						id,
						feature_id,
						feature,
						compat_status,
						popularity_map,
						&mut all_groups,
						&mut all_specs,
					);
					feature_entries.push((id.to_string(), entry));
				}
			}
		}
	}

	feature_entries.sort_by(|a, b| a.0.cmp(&b.0));
	let feature_entries: Vec<TokenStream> = feature_entries.into_iter().map(|(_, tokens)| tokens).collect();

	let mut sorted_groups: Vec<_> = all_groups.into_iter().collect();
	sorted_groups.sort_by(|a, b| a.0.cmp(&b.0));
	let group_entries: Vec<TokenStream> = sorted_groups
		.into_iter()
		.filter(|(group, _)| !group.is_empty())
		.map(|(group, members)| {
			let mut sorted_members: Vec<_> = members.into_iter().collect();
			sorted_members.sort();
			let member_strs = sorted_members.iter().map(|m| m.as_str());
			quote! {
				#group => &[#(#member_strs),*]
			}
		})
		.collect();

	let mut sorted_specs: Vec<_> = all_specs.into_iter().collect();
	sorted_specs.sort_by(|a, b| a.0.cmp(&b.0));
	let spec_entries: Vec<TokenStream> = sorted_specs
		.into_iter()
		.filter(|(spec, _)| !spec.is_empty())
		.map(|(spec, members)| {
			let mut sorted_members: Vec<_> = members.into_iter().collect();
			sorted_members.sort();
			let member_strs = sorted_members.iter().map(|m| m.as_str());
			quote! {
				#spec => &[#(#member_strs),*]
			}
		})
		.collect();

	let tokens = quote! {
		use crate::*;
		use phf::{phf_map, Map};
		use chrono::NaiveDate;

		pub static CSS_FEATURES: Map<&'static str, CSSFeature> = phf_map! {
			#(#feature_entries)*
		};

		pub static GROUPS: Map<&'static str, &'static [&'static str]> = phf_map! {
			#(#group_entries),*
		};

		pub static SPECS: Map<&'static str, &'static [&'static str]> = phf_map! {
			#(#spec_entries),*
		};
	};

	let file: File = parse2(tokens).expect("generated code should parse");
	let code = prettyplease::unparse(&file);

	format!("//! Auto-generated CSS features data\n\n{}", code)
}

fn generate_feature_entry_tokens(
	id: &str,
	feature_id: &str,
	feature: &FeatureData,
	compat_status: &crate::web_features_data::CompatKeyStatus,
	popularity_map: &HashMap<String, f64>,
	all_groups: &mut HashMap<String, HashSet<String>>,
	all_specs: &mut HashMap<String, HashSet<String>>,
) -> TokenStream {
	let name = feature.name.as_deref().unwrap_or("");
	let description = feature.description.as_deref().unwrap_or("");

	let spec = if let Some(spec_val) = &feature.spec {
		match spec_val {
			StringOrArray::Single(s) => s.as_str(),
			StringOrArray::Multiple(v) => v.first().map(|s| s.as_str()).unwrap_or(""),
		}
	} else {
		""
	};

	if !spec.is_empty()
		&& let Some(spec_val) = &feature.spec
	{
		match spec_val {
			StringOrArray::Single(s) => {
				all_specs.entry(s.clone()).or_default().insert(id.to_string());
			}
			StringOrArray::Multiple(v) => {
				for s in v {
					all_specs.entry(s.clone()).or_default().insert(id.to_string());
				}
			}
		}
	}

	let groups: Vec<&str> = if let Some(group_val) = &feature.group {
		match group_val {
			StringOrArray::Single(s) => {
				if !s.is_empty() && s != "css" {
					all_groups.entry(s.clone()).or_default().insert(id.to_string());
					vec![s.as_str()]
				} else {
					vec![]
				}
			}
			StringOrArray::Multiple(v) => v
				.iter()
				.filter(|g| !g.is_empty() && g.as_str() != "css")
				.map(|g| {
					all_groups.entry(g.clone()).or_default().insert(id.to_string());
					g.as_str()
				})
				.collect(),
		}
	} else {
		vec![]
	};

	let baseline_status = generate_baseline_status_tokens(
		&compat_status.baseline,
		compat_status.baseline_high_date.as_deref(),
		compat_status.baseline_low_date.as_deref(),
	);

	let browser_support = generate_browser_support_tokens(&compat_status.support);

	let caniuse: Vec<String> = if let Some(caniuse_val) = &feature.caniuse {
		match caniuse_val {
			StringOrArray::Single(s) => {
				if !s.is_empty() {
					vec![format!("https://caniuse.com/{}", s)]
				} else {
					vec![]
				}
			}
			StringOrArray::Multiple(v) => {
				v.iter().filter(|s| !s.is_empty()).map(|s| format!("https://caniuse.com/{}", s)).collect()
			}
		}
	} else {
		vec![]
	};

	let caniuse_strs: Vec<&str> = caniuse.iter().map(|s| s.as_str()).collect();

	let popularity = popularity_map.get(feature_id).copied().unwrap_or(0.0) as f32;

	quote! {
		#id => CSSFeature {
			id: #id,
			name: #name,
			description: #description,
			spec: #spec,
			groups: &[#(#groups),*],
			baseline_status: #baseline_status,
			browser_support: #browser_support,
			caniuse: &[#(#caniuse_strs),*],
			popularity: #popularity,
		},
	}
}

fn generate_baseline_status_tokens(
	baseline: &BaselineStatus,
	high_date: Option<&str>,
	low_date: Option<&str>,
) -> TokenStream {
	match baseline {
		BaselineStatus::String(s) if s == "high" => {
			let since = date_str_to_naive_date_tokens(high_date.unwrap_or(""));
			let low_since = date_str_to_naive_date_tokens(low_date.unwrap_or(""));
			quote! {
				BaselineStatus::High { since: #since, low_since: #low_since }
			}
		}
		BaselineStatus::String(s) if s == "low" => {
			let low_since = date_str_to_naive_date_tokens(low_date.unwrap_or(""));
			quote! {
				BaselineStatus::Low(#low_since)
			}
		}
		BaselineStatus::Bool(false) => quote! { BaselineStatus::False },
		_ => quote! { BaselineStatus::Unknown },
	}
}

fn date_str_to_naive_date_tokens(date: &str) -> TokenStream {
	let parts: Vec<&str> = date.split('-').collect();
	if parts.len() != 3 {
		return quote! { NaiveDate::from_ymd_opt(1970, 1, 1).unwrap() };
	}

	let mut year = parts[0];
	if year.len() > 4 {
		year = &year[year.len() - 4..];
	}

	let year_num: i32 = year.parse().unwrap_or(1970);
	let month_num: u32 = parts[1].parse().unwrap_or(1);
	let day_num: u32 = parts[2].parse().unwrap_or(1);

	quote! { NaiveDate::from_ymd_opt(#year_num, #month_num, #day_num).unwrap() }
}

fn generate_browser_support_tokens(support: &crate::web_features_data::SupportData) -> TokenStream {
	let chrome = browser_version_tokens(support.chrome.as_deref());
	let chrome_android = browser_version_tokens(support.chrome_android.as_deref());
	let edge = browser_version_tokens(support.edge.as_deref());
	let firefox = browser_version_tokens(support.firefox.as_deref());
	let firefox_android = browser_version_tokens(support.firefox_android.as_deref());
	let safari = browser_version_tokens(support.safari.as_deref());
	let safari_ios = browser_version_tokens(support.safari_ios.as_deref());

	quote! {
		BrowserSupport {
			chrome: #chrome,
			chrome_android: #chrome_android,
			edge: #edge,
			firefox: #firefox,
			firefox_android: #firefox_android,
			safari: #safari,
			safari_ios: #safari_ios,
		}
	}
}

fn browser_version_tokens(version: Option<&str>) -> TokenStream {
	if let Some(ver) = version {
		if ver.is_empty() {
			return quote! { BrowserVersion(0, 0) };
		}

		if ver.chars().all(|c| c.is_ascii_digit() || c == '.') {
			let parts: Vec<&str> = ver.split('.').collect();
			let major: u16 = parts.first().and_then(|s| s.parse().ok()).unwrap_or(0);
			let minor: u16 = parts.get(1).and_then(|s| s.parse().ok()).unwrap_or(0);
			return quote! { BrowserVersion(#major, #minor) };
		}
	}

	quote! { BrowserVersion(0, 0) }
}

pub fn generate_property_atoms(property_names: &std::collections::HashSet<String>) -> String {
	use heck::ToKebabCase;
	use quote::{format_ident, quote};
	use std::collections::HashSet;

	let css_atom_set_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
		.parent()
		.unwrap()
		.join("css_ast")
		.join("src")
		.join("css_atom_set.rs");

	let css_atom_set_content = std::fs::read_to_string(&css_atom_set_path).expect("Failed to read css_atom_set.rs");

	let existing_variants: HashSet<String> = css_atom_set_content
		.lines()
		.filter_map(|line| {
			let trimmed = line.trim();
			if trimmed.starts_with("_") || (trimmed.chars().next()?.is_ascii_uppercase() && trimmed.contains(',')) {
				trimmed.trim_end_matches(',').split_whitespace().next().map(String::from)
			} else {
				None
			}
		})
		.collect();

	let to_pascal_case = |name: &str| -> String {
		name.split('-')
			.map(|part| {
				let mut chars = part.chars();
				match chars.next() {
					None => String::new(),
					Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
				}
			})
			.collect()
	};

	let mut variants: Vec<_> = property_names
		.iter()
		.filter_map(|name| {
			if !name.chars().all(|c| c.is_alphanumeric() || c == '-') {
				return None;
			}

			let pascal = to_pascal_case(name);
			if pascal.is_empty() || pascal.chars().next()?.is_ascii_digit() {
				return None;
			}

			let kebab = pascal.to_kebab_case();
			let needs_prefix = matches!(kebab.split("-").next().unwrap_or_default(), "Webkit" | "Moz" | "Ms" | "O");
			let variant_name = if needs_prefix { format!("_{}", pascal) } else { pascal };

			if !existing_variants.contains(&variant_name) {
				return None;
			}

			Some(format_ident!("{}", variant_name))
		})
		.collect();

	variants.sort_by_key(|a| a.to_string());

	let source = quote! {
		use crate::CssAtomSet::*;

		/// CSS property atoms from W3C specs.
		///
		/// AUTO-GENERATED by csskit_spec_generator. Run `mise run generate-property-atoms` to regenerate.
		#[allow(dead_code)]
		pub const CSS_PROPERTY_ATOMS: &[crate::CssAtomSet] = &[
			#(#variants,)*
		];
	};

	let contents = syn::parse_file(&source.to_string()).expect("Failed to parse generated code");
	prettyplease::unparse(&contents)
}
