---
source: crates/csskit_proc_macro/src/test.rs
expression: pretty
---
struct Foo<'a>(pub ::css_parse::T![Ident], pub crate::Length);
#[automatically_derived]
impl<'a> ::css_parse::Parse<'a> for Foo<'a> {
    fn parse(p: &mut ::css_parse::Parser<'a>) -> ::css_parse::Result<Self> {
        use ::css_parse::{Parse, Peek};
        let mut val0: Option<::css_parse::T![Ident]> = None;
        let mut val1: Option<crate::Length> = None;
        loop {
            let c = p.peek_n(1);
            if val0.is_none() && <FooKeywords>::peek(p, c) {
                val0 = Some(p.parse::<FooKeywords>()?.into());
                continue;
            }
            if val1.is_none() && <crate::Length>::peek(p, c) {
                let ty = p.parse::<crate::Length>()?;
                if !(0f32..=100f32).contains(&Into::<f32>::into(ty)) {
                    use css_parse::ToSpan;
                    Err(
                        ::css_parse::diagnostics::NumberOutOfBounds(
                            ty.into(),
                            format!("{}..{}", 0f32, 100f32),
                            ty.to_span(),
                        ),
                    )?
                }
                val1 = Some(ty);
                continue;
            }
            break;
        }
        if val0.is_none() || val1.is_none() {
            let c = p.peek_n(1);
            Err(::css_parse::diagnostics::Unexpected(c.into(), c.into()))?
        }
        Ok(Self(val0.unwrap(), val1.unwrap()))
    }
}
