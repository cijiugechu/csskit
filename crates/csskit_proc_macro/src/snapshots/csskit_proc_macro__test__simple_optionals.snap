---
source: crates/csskit_proc_macro/src/test.rs
expression: pretty
---
struct Foo<'a>(pub crate::Length, pub ::css_parse::T![Ident]);
#[automatically_derived]
impl<'a> ::css_parse::Parse<'a> for Foo<'a> {
    fn parse(p: &mut ::css_parse::Parser<'a>) -> ::css_parse::Result<Self> {
        use ::css_parse::{Parse, Peek};
        let mut val0: Option<crate::Length> = None;
        let mut val1: Option<::css_parse::T![Ident]> = None;
        loop {
            let c = p.peek_n(1);
            if val0.is_none() && <crate::Length>::peek(p, c) {
                val0 = Some(p.parse::<crate::Length>()?);
                continue;
            }
            if val1.is_none() && <FooKeywords>::peek(p, c) {
                val1 = Some(p.parse::<FooKeywords>()?.into());
                continue;
            }
            break;
        }
        if val0.is_none() || val1.is_none() {
            let c = p.peek_n(1);
            Err(::css_parse::diagnostics::Unexpected(c.into(), c.into()))?
        }
        Ok(Self(val0.unwrap(), val1.unwrap()))
    }
}
