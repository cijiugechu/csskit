---
source: crates/csskit_derives/src/test/test_parse.rs
expression: pretty
---
#[automatically_derived]
impl<'a> ::css_parse::Parse<'a> for AllMustOccurEnum {
    fn parse(p: &mut css_parse::Parser<'a>) -> css_parse::Result<Self> {
        use css_parse::{Parse, Peek};
        if p.peek::<AutoValue>() {
            let c = p.peek_n(1);
            match p.to_atom::<FooKeywords>(c) {
                FooKeywords::Auto => {
                    let mut auto_field: Option<AutoValue> = None;
                    let mut none_field: Option<NoneValue> = None;
                    let mut length: Option<Length> = None;
                    loop {
                        let c = p.peek_n(1);
                        let atom = p.to_atom::<FooKeywords>(c);
                        if auto_field.is_none() && atom == FooKeywords::Auto {
                            auto_field = Some(p.parse::<AutoValue>()?);
                            continue;
                        }
                        if none_field.is_none() && atom == FooKeywords::None {
                            none_field = Some(p.parse::<NoneValue>()?);
                            continue;
                        }
                        if length.is_none() && <Length>::peek(p, c) {
                            length = Some(p.parse::<Length>()?);
                            continue;
                        }
                        break;
                    }
                    if auto_field.is_none() || none_field.is_none() || length.is_none() {
                        let c = p.peek_n(1);
                        Err(crate::Diagnostic::new(c, crate::Diagnostic::unexpected))?
                    }
                    return Ok(Self::Complex {
                        auto_field: auto_field.unwrap(),
                        none_field: none_field.unwrap(),
                        length: length.unwrap(),
                    });
                }
                _ => {}
            }
        }
        {
            let f0 = p.parse::<String>()?;
            return Ok(Self::Simple { 0: f0 });
        }
    }
}
