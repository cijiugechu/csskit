#!/usr/bin/env bash
set -eu pipefail
#MISE description="Generate a release, or a release PR"
#USAGE flag "--dryrun" help="Run in dry-run mode (no git/publish/write operations)"

# Check if dry-run mode is enabled
DRY_RUN="${usage_dryrun:-false}"

# Get current version from Cargo workspace
BRANCH=$(git rev-parse --abbrev-ref HEAD)
echo "Current branch:  $BRANCH"

SHA=$(git rev-parse HEAD | cut -b 1-10)
echo "Current SHA:     $SHA"

VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[] | select(.name == "csskit") | .version' | sed 's/.*/v&/')
echo "Current version: $VERSION"

NEXT_VERSION="$(git cliff --bumped-version --unreleased)"
echo "Next version:    $NEXT_VERSION"

CANARY_VERSION="${NEXT_VERSION}-canary.${SHA}"
echo "Canary Version:  $CANARY_VERSION"

# Check if this version has already been released
released_versions="$(git tag --list | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)"
if echo "$released_versions" | grep -q "^$VERSION$"; then
	MODE="CANARY"
else
	MODE="RELEASE"
fi
echo "Mode: $MODE"
echo "==========================="
#
# Only run on main or release branches (unless dry-run)
if [[ "$BRANCH" != "main" && "$BRANCH" != "release" && "$DRY_RUN" != "true" ]]; then
	echo "Not on main or release branch, skipping release"
	exit 0
fi

if [[ "$DRY_RUN" == "true" ]]; then
	git cliff -o CHANGELOG.md
fi

if [[ "$MODE" == "RELEASE" ]]; then
	# RELEASE MODE: Deploy all crates & packages
	echo "Deploying version $VERSION..."

	# This would be called after a release PR is merged to main
	# The workflow should handle the actual cargo publish and npm publish
	# Just set the tag name for the workflow to use
	if [[ "$DRY_RUN" == "true" ]]; then
		echo "Would have created $VERSION"
		cargo publish --allow-dirty --dry-run
		exit 0
	fi

	git config user.name "Keith Cirkel"
	git config user.email "keithamus@users.noreply.github.com"

	# Release platform-specific npm packages first
	for platform_pkg in packages/csskit-*/; do
		pushd "$platform_pkg"
		npm version "${VERSION#v}" --no-git-tag-version
		echo "Publishing $platform_pkg"
		npm pub --provenance --tag next --access public --loglevel=silly
		popd
	done

	# Update optionalDependencies versions in main package & release
	pushd packages/csskit
	node -e "
		const fs = require('fs');
		const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
		if (pkg.optionalDependencies) {
			for (const dep in pkg.optionalDependencies) {
				pkg.optionalDependencies[dep] = '${VERSION#v}';
			}
		}
		fs.writeFileSync('package.json', JSON.stringify(pkg, null, 4) + '\n');
	"
	echo "Publishing csskit"
	npm version "${VERSION#v}" --no-git-tag-version
	npm pub --provenance --tag next --access public --loglevel=silly
	popd

	# Release all cargo crates
	cargo publish --allow-dirty

	# Update GitHub release
	gh release create "$VERSION" --generate-notes
	gh release upload "$VERSION" binary-*/*

else
	# CANARY MODE: Create/update release PR
	echo "Creating/updating release PR..."

	# Generate changelog for unreleased commits
	changelog="$(git cliff --bump --unreleased --strip all)"

	echo "=========================================="
	echo "CHANGELOG PREVIEW:"
	echo "=========================================="
	echo "$changelog"
	echo "=========================================="

	if [[ "$DRY_RUN" == "true" ]]; then
		exit 0
	fi

	git config user.name "Keith Cirkel"
	git config user.email "keithamus@users.noreply.github.com"

	# Update CHANGELOG.md
	git cliff --bump -o CHANGELOG.md

	# Replace versions in Cargo.toml
	sed -i "/@release/s/version = \"[^\"]*\"/version = \"${NEXT_VERSION#v}\"/g" Cargo.toml

	npm whoami

	# Replace versions in npm packages
	for platform_pkg in packages/csskit-*/ packages/csskit/; do
		pushd "$platform_pkg"
		npm version "${NEXT_VERSION#v}" --no-git-tag-version
		popd
	done

	# Update optionalDependencies versions in main package
	pushd packages/csskit
	node -e "
		const fs = require('fs');
		const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
		if (pkg.optionalDependencies) {
			for (const dep in pkg.optionalDependencies) {
				pkg.optionalDependencies[dep] = '${NEXT_VERSION#v}';
			}
		}
		fs.writeFileSync('package.json', JSON.stringify(pkg, null, 4) + '\n');
	"
	popd

	BRANCH="release-${NEXT_VERSION}"

	# Create release commit
	git commit -am"Release: ${NEXT_VERSION}" -m"${changelog}"
	git push --force origin HEAD:refs/heads/"${BRANCH}"

	# Create or update PR
	gh pr edit "${BRANCH}" \
		--title "Release ${NEXT_VERSION}" \
		--body "$changelog" ||
		gh pr create \
			--title "Release ${NEXT_VERSION}" \
			--body "$changelog" \
			--label "release" \
			--base main \
			--head "${BRANCH}"

	################
	# Canary Release
	################

	# Replace the versions in Cargo.toml
	sed -i "/@release/s/version = \"[^\"]*\"/version = \"${CANARY_VERSION#v}\"/g" Cargo.toml

	# Commit changes
	git commit -am'Canary Release' -m"${changelog}" --amend
	CANARY_SHA=$(git rev-parse HEAD | cut -b 1-10)

	# Replace the canary tag with the current SHA
	git tag -fa canary -m "Latest Continuous Release" "${CANARY_SHA}"
	git push --force origin canary:refs/tags/canary

	# Update GitHub release
	gh release upload canary binary-*/* --clobber

	# Release platform-specific npm packages first
	for platform_pkg in packages/csskit-*/; do
		pushd "$platform_pkg"
		npm version "${CANARY_VERSION#v}" --no-git-tag-version
		npm pub --provenance --tag canary --access public
		popd
	done

	# Update optionalDependencies versions in main package & release
	pushd packages/csskit
	node -e "
		const fs = require('fs');
		const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
		if (pkg.optionalDependencies) {
			for (const dep in pkg.optionalDependencies) {
				pkg.optionalDependencies[dep] = '${CANARY_VERSION#v}';
			}
		}
		fs.writeFileSync('package.json', JSON.stringify(pkg, null, 4) + '\n');
	"
	npm version "${CANARY_VERSION#v}" --no-git-tag-version
	npm pub --provenance --tag canary --access public
	popd

	# Release all cargo crates
	cargo publish --allow-dirty
fi
